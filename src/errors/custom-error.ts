// Abstract classes are mainly for inheritance where other classes may derive from them. We cannot create an instance of an abstract class.
// Abstract classes are implemented as regular classes in the JavaScript generated by the TypeScript compiler. The drawback of this approach is that it is the TypeScript compiler that prevents abstract classes from being instantiated, and this isn’t carried over into the JavaScript code, potentially allowing objects to be created from the abstract class. However, this approach does mean that the instanceof keyword can be used to narrow types
// An interface only allows you to define functionality, not implement it. And whereas a class can extend only one abstract class, it can take advantage of multiple interfaces.
// An interface can contain only method declarations; it cannot contain method definitions. Nor can you have any member data in an interface. Whereas an abstract class may contain method definitions, fields, and constructors, an interface may only have declarations of events, methods, and properties.
// we want to add more custom properties to the error object. so we are subclassing
export abstract class CustomError extends Error {
  abstract statusCode: number;
  //   this will be passed by Error to write a "new Error" for logging purposes. it wont be sent to users
  constructor(message: string) {
    super(message);
    // every function has a prototype object that’s automatically set as the prototype of the objects created with that function.
    // this is set to be able to use isntance of method
    Object.setPrototypeOf(this, CustomError.prototype);
  }
  //   this is not a method. it is a method signature. abstract class should have at least one method
  abstract serializeErrors(): { message: string; field?: string }[];
}
